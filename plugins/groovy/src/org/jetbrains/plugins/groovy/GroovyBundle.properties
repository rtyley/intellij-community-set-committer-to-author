#
#  Copyright 2000-2007 JetBrains s.r.o.
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#

########################################################################################################################
# Groovy script template
########################################################################################################################
error.file.already.exists=File with same name already exists

file.template.group.title.groovy=Groovy

newclass.dlg.title=New Groovy Class
newclass.menu.action.text=Groovy Class
newclass.menu.action.description=Creates new Groovy Class
newclass.command.name=Create Groovy Class
newclass.progress.text=Creating Groovy Class ''{0}''

newinterface.dlg.prompt=Enter name for new Groovy Interface
newinterface.dlg.title=New Groovy Interface
newinterface.menu.action.text=Groovy Interface
newinterface.menu.action.description=Creates new Groovy Interface
newinterface.command.name=Create Groovy Interface
newinterface.progress.text=Creating Groovy Interface ''{0}''

newannot.dlg.prompt=Enter name for new Groovy Annotation
newannot.dlg.title=New Groovy Annotation
newannot.menu.action.text=Groovy Annotation
newannot.menu.action.description=Creates new Groovy Annotation
newannot.command.name=Create Groovy Annotation
newannot.progress.text=Creating Groovy Annotation ''{0}''

newenum.dlg.prompt=Enter name for new Groovy Enumeration
newenum.dlg.title=New Groovy Enumeration
newenum.menu.action.text=Groovy Enumeration
newenum.menu.action.description=Creates new Groovy Enumeration
newenum.command.name=Create Groovy Enumeration
newenum.progress.text=Creating Groovy Enumeration ''{0}''

newscript.dlg.prompt=Enter name for new Groovy Script
newscript.dlg.title=New Groovy Script
newscript.menu.action.text=Groovy Script
newscript.menu.action.description=Creates new Groovy Script
newscript.command.name=Create Groovy Script
newscript.progress.text=Creating Groovy Script ''{0}''

action.group.groovy.title=Groovy
action.group.groovy.description=Groovy

##########################################################################################################################
# GDK & compilation
########################################################################################################################

cannot.compile.groovy.files.no.facet=Cannot find Groovy home for module ''{0}''.\nYou should either:\n\
- invoke 'Add Framework support' action for this module,\n\
or:\n\
- add Groovy jars to module classpath manually.
cannot.compile.groovy.files.no.sdk=Cannot Compile Groovy Files.\nPlease Set up SDK for module ''{0}''.
cannot.compile.groovy.files.no.sdk.mult=Cannot Compile Groovy Files.\nPlease Set up SDK for modules ''{0}''.
cannot.compile=Cannot Compile
debug.option=Enable &debug stacktrace
groovy.debug.disable.specific.methods=Do not step &into specific Groovy classes
groovy.debug.caption=Groovy

########################################################################################################################
# Parser error messages
########################################################################################################################

separator.expected=';' or new line expected
separator.or.rcurly.expected=';', '}' or new line expected
import.keyword.expected='import' expected
import.identifier.expected=package or class name expected
identifier.expected=Identifier expected
import.not.allowed=Imports are not allowed inside blocks
identifier.or.block.expected=Identifier or code block expected
package.keyword.expected='package' expected
string.end.expected=String end expected
regex.end.expected=Regex ending expected
mult.expression.expected=Multiplicative expression expected
closure.op.expected='->' expected
lbrack.expected='[' expected
rbrack.expected=']' expected
upper.case.ident.or.builtIn.type.or.qualified.type.name.expected=upper case identifier or built in type or qualified type name expected
balanced.tokens.expected=balanced tokens expected
lparen.expected='(' expected
lcurly.expected='{' expected
comma.expected=',' expected
start.of.string.expected=start of string expected
end.of.string.expected=end of string expected
rcurly.expected='}' expected
rparen.expected=')' expected
semi.expected=';' expected
gt.expected='>' expected
else.without.if='else' without 'if'
catch.without.try='catch' without 'try'
finally.without.try='finally' without 'try'
case.without.switch='case' outside 'switch' block
default.without.switch='default' outside 'switch' block
catch.or.finally.expected='catch' or 'finally' expected
colon.expected=':' expected
lbrack.or.lparen.or.lcurly.or.string_ctor_start.expected='[', '{', '{' or start of the string expected
wrong.declaration=Wrong declaration
wrong.statement=Wrong statement
variable.definitions.expected=Variable definition expected
method.definitions.expected=Method definition expected
type.specification.expected=Type specification expected
modifier.expected=Modifier expected
annotation.or.modifier.expected=Annotation or modifier expected
type.definition.expected=Type definition expected
expression.expected=Expression expected
annotation.initializer.expected=Annotation initializer expected
annotation.member.value.initializer.expected=Annotation member value initializer expected
case.block.expected=Case block expected
case.expected='case' or 'default' expected
block.expression.expected=Block expression expected
wrong.string=Wrong string literal
path.selector.expected=Property selector expected
duplicate.modifier=Duplicate modifier
param.expected=Parameter expected
for.clause.expected=clause expected
at.expected='@' expected
intarface.expected='interface' expected
if.expected='if' expected
compound.statemenet.expected=Initializer block expected
indentifier.or.string.or.left.parenth.literal.expected=Identifier, string literal or '(' expected

empty.parameter.list.expected=empty parameter list expected
string.name.unexpected=string name unexpected
method.definition.without.modifier=Method definition must be precede by modifier, type or 'def' keyword
interface.body.expected=interface body expected
interface.must.has.no.static.compound.statemenet=static compound statement unexpected in interface
interface.must.has.no.compound.statemenet=compound statement unexpected in interface

########################################################################################################################
# Intentions & error messages
########################################################################################################################
cannot.resolve=Cannot resolve symbol ''{0}''
ambiguous.constructor.call=Ambiguous constructor call
cannot.access=Access to ''{0}'' exceeds its access rights
cannot.reference.static=Cannot reference static symbol ''{0}'', class qualifier needed
cannot.reference.nonstatic=Cannot reference nonstatic symbol ''{0}'' from static context
cannot.return.from.constructor=Cannot return an object from constructor
cannot.return.from.void.method=Cannot return an object from a method that returns 'void'
cannot.apply.method.or.closure=''{0}'' cannot be applied to ''{1}''
cannot.apply.method1=''{0}'' in ''{1}'' cannot be applied to ''{2}''
cannot.find.default.constructor=Cannot apply default constructor for class ''{0}''
cannot.instantiate.abstract.class=Cannot instantiate abstract class ''{0}''
cannot.instantiate.interface=Cannot instantiate interface ''{0}''
cannot.assign=Cannot assign ''{0}'' to ''{1}''
invalid.lvalue=Invalid value to assign to
duplicate.class=Class ''{0}'' already exists in ''{1}''
duplicate.inner.class=Duplicate class: ''{0}''
script.generated.with.same.name=There is a synthetic class ''{0}'' generated for script code
variable.already.defined=Variable ''{0}'' already defined
field.already.defined=Field ''{0}'' already defined
import.what=Import ''{0}''
import.class=Import Class
create.class.family.name=Create Class
create.class.text=Create Class ''{0}''
dynamize.invalid.interface.text=Dynamize invalid interface instantiation
dynamize.invalid.interface.family.name=Dynamize invalid code
class.to.import.chooser.title=Choose class to import
unused.import.statement=Unused import statement
static.declaration.in.inner.class=Inner classes cannot have static declarations
constructors.are.not.allowed.in.anonymous.class=Constructors are not allowed in anonymous class
no.such.property=Property ''{0}'' does not exist

# {0} - colspan, {1} - method name, {2} - class name, {3} - formal myParameters row, {4} - arguments row
argument.mismatch.html.tooltip=\
  <html><body><table border=0>\
  <tr><td><b>{1}</b></td>{3}<td colspan={0}>in <b>{2}</b>\\&nbsp;cannot be applied</td></tr>\
  <tr><td>to</td>{4}</tr>\
  </table></body></html>

########################################################################################################################
# Compiler
########################################################################################################################
class.already.exists=Class ''{0}'' already exists

selected.block.should.represent.an.expression=Selected code block must represent an expression
annotation.definition.qualified.name.expected=annotation definition qualified name expected
type.expected=type expected
type.parameter.expected=Type parameter expected
type.argument.expected=Type argument expected

repetitive.method.name.signature=Repetitive method name/signature
repetitive.method.name.signature.and.return.type=repetitive method name, signature and return type
illegal.combination.of.modifiers=illegal combination of modifiers
modifier.is.not.allowed.here.0=modifier ''{0}'' is not allowed here
illegal.combination.of.modifiers.abstract.and.final=illegal combination of modifiers 'abstract' and 'final'
modifier.volatile.not.allowed.here=modifier 'volatile' not allowed here
modifier.transient.not.allowed.here=modifier 'transient' not allowed here
intarface.cannot.have.modifier.final=interface cannot have modifier 'final'
script.cannot.have.modifier.abstract=script cannot have modifier 'abstract'
script.cannot.have.modifier.native=script cannot have modifier 'native'
interface.must.have.no.static.method=interface must have no static method
not.abstract.class.cannot.have.abstract.method=not abstract class cannot have abstract method
illegal.combination.of.modifiers.volatile.and.final=illegal combination of modifiers 'volatile' and 'final'
variable.cannot.be.native=variable cannot have modifier 'native'
variable.cannot.be.abstract=variable cannot have modifier 'abstract'
not.abstract.class.cannot.have.method.without.body=not abstract class cannot have method without body
not.abstract.method.should.have.body=not abstract method should have body
cannot.create.class.error.text=Cannot Create Class ''{0}'': {1}
cannot.create.class.error.title=Cannot Create Class
no.class.in.file.template=No Class Found in File Template
interface.must.have.no.private.method=interface must have no private method
error.external=External error
Inner.methods.are.not.supported=Inner methods are not supported
final.class.cannot.be.extended=Final class cannot be extended

#Override and implement
goto.override.method.declaration=go to override method declaration
interface.expected.here=Interface is expected here
overrides.method.from.super=Overrides method in ''{0}''
implements.method.from.super=Implements method in ''{0}''
select.methods.to.implement=Select methods to implement
select.methods.to.override=Select methods to override
implement.methods=Implement methods
implement.methods.fix=Implement methods
method.is.not.implemented=Method ''{0}'' is not implemented
interface.is.not.expected.here=Interface is not expected here
change.implements.and.extends.classes=Normalize extends and implements lists

unsafe.dereference=Unsafe dereference
type.definition.can.extend.just.one.super.type=Type definition must extends not more than one class
class.is.not.expected.here=Class is not expected here
interface.cannot.contain.implements.clause=Interface cannot contain implements clause
fix.package.name=Fix package name

#dynamic properties
add.dynamic.property=Add dynamic property ''{0}''
duplicate.element.in.the.map=Duplicate element in the map
message.nothing.to.show.in.structure.view=There are no dynamic properties
dynamic.toolwindow.search.elements=Search dynamic element
dynamic.toolwindow.property.fiter=Property Filter
dynamic.tool.window.id=Dynamic properties

create.from.usage.family.name=Create From Usage
create.field.from.usage=Create Field ''{0}''
create.method.from.usage=Create Method ''{0}''
create.variable.from.usage=Create Variable ''{0}''
add.dynamic.element=Add dynamic element
add.dynamic.method=Add dynamic method
dynamic.type=Type
dynamic.name=Name
dynamic.properties.table.name=Method arguments
dynamic.method.return.type=Return type
dynamic.method.property.type=Property type
are.you.sure.to.delete.dynamic.property=Are you sure to delete ''{0}''?
dynamic.property.deletion=Deletion dynamic property
are.you.sure.to.delete.elements=Are you sure to delete ''{0}'' elements?
dynamic.element.deletion=Dynamic element deletion
dynamic.window=Dynamic window
dynamic.properties.table.no.arguments=Arguments list is empty.
assignment.expected='=' expected
tuple.cant.be.placed.in.class=Multiple assignments are not allowed for fields
immutable.class.should.be.final=Class with '@Immutable' annotation should be final
singleton.class.should.have.private.constructor=Class with '@Singleton' annotation should have private constructor
qualified.new.of.static.class=Qualified new of static class
cannot.have.static.declarations=Inner classes cannot have static declarations
unknown.class=unknown class ''{0}''
is.not.enclosing.class=''{0}'' is not an enclosing class
package.definition.cannot.have.modifiers=Package definiton cannot have modifiers
import.statement.cannot.have.modifiers=Import statement cannot have modifiers
inner.classes.are.not.supported=Inner classes are not supported in Groovy {0}
anonymous.classes.are.not.supported=Anonymous classes are not supported in Groovy {0}
undefined.label=Undefined label ''{0}''
continue.outside.loop=The continue statement is only allowed inside loops
break.outside.loop.or.switch=The break statement is only allowed inside loops or switches
label.already.used=Label ''{0}'' is already in use
break.outside.loop=The break statement with named labels is only allowed inside loops
########################################################################################################################
# Facet configuration
########################################################################################################################
groovy.sdk.configuration=Groovy SDK configuration
new.button.label=New
groovy.sdk.configuration.label=<html><b>Groovy SDK:</b><br>Choose Groovy SDK specific for this module</html>
add.new.groovy.lib=New SDK
invalid.groovy.sdk.path.message=Invalid path to Groovy SDK
invalid.groovy.sdk.path.text=Wrong path specified
duplicate.groovy.lib.version=Duplicated Groovy SDK version
duplicate.groovy.lib.version.add=Add one more Groovy SDK of version {0}?
groovy.sdk.combo.box.project.item=<No Groovy SDK>
Constructor=Constructor
facet.create.project.lib=Create &Project Groovy library ''{0}''
facet.create.application.lib=Create Glob&al Groovy library ''{0}''
groovy.like.library.found=Groovy library found
groovy.like.library.found.text=Do you want to set up Groovy for module ''{0}'' \n\
with found library ''{1}'' (Groovy version {2})?
compile.groovy.files=&Compile Groovy files
copy.groovy.files.to.output=Copy Groovy files to output as &resources
in.expected='in' expected
not.allowed.modifier.in.forin=Modifier ''{0}'' is not allowed here
